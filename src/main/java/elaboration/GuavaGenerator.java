package elaboration;

import spril.Instruction;
import spril.MemAddr;
import spril.Op;
import spril.Target;
import grammar.GuavaBaseVisitor;
import grammar.GuavaParser;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeProperty;
import org.junit.Assert;

import java.util.*;

public class GuavaGenerator extends GuavaBaseVisitor<String> {
    /** This is the result of the checking phase.*/
    private CheckerResult result;

    /** This is the list with instructions which will be filled during the code generation.*/
    private List<String> instructions;

    /** The ParseTreeProperty and Map are used for register allocation and retrieval of registers for certain nodes.*/
    private ParseTreeProperty<String> registers;

    /** This is a list of all registers which can be overwritten.*/
    private List<String> emptyRegisters;

    /** This ParseTreeProperty is used to store the number of lines generated by each specific ParseTree.
     *  This is used to determine where to jump to in the if, while and for statements.*/
    private ParseTreeProperty<Integer> codeLines;

    /** Variables declared in for-loops will be stored here. These variables are saved and handled entirely in
     *  registers, to speed up execution*/
    private Map<String, String> nestedVars;

    /** OPTIMIZATION*/

    private Map<String, String> loadedVariables;

    private ParseTreeProperty<List<String>> arrayValues;

    /** Will be set to true when a for-loop declaration is entered, to ensure some registers do not get emptied*/
    private boolean nested;

    private static ParserRuleContext END;

    private static final String CONST = "CONST";
    private static final String DIR = "DIR";
    private static final String REG0 = "reg0";
    private static final String TRUE = "1";
    private static final String FALSE = "0";

    public GuavaGenerator(ParseTree tree, CheckerResult result, String[] availableRegs) {
        Assert.assertTrue(result != null);

        this.result = result;
        this.instructions = new ArrayList<>();
        this.registers = new ParseTreeProperty<>();
        this.emptyRegisters = new ArrayList<>();
        this.codeLines = new ParseTreeProperty<>();
        this.nestedVars = new HashMap<>();
        this.loadedVariables = new HashMap<>();
        this.arrayValues = new ParseTreeProperty<>();
        this.nested = false;

        Collections.addAll(emptyRegisters, availableRegs);
        tree.accept(this);
    }

    /**
     * Get the list of instructions generated by the generator
     * @return the list of instructions
     */
    public List<String> getInstructions() {
        return this.instructions;
    }

    // Statements ------------------------------------------------------------------------------------------------------
    @Override
    public String visitProgram(GuavaParser.ProgramContext ctx) {
        END = ctx;
        visitChildren(ctx);
        addInstr(new Instruction.EndProg());
        return null;
    }

    @Override
    public String visitBody(GuavaParser.BodyContext ctx) {
        visitChildren(ctx);
        return null;
    }

    @Override
    public String visitGlobalDecl(GuavaParser.GlobalDeclContext ctx) {
        int lines = 0;

        if (ctx.expr() != null) {
            visit(ctx.expr());
            lines += getCodeLines(ctx.expr());

            Instruction write;
            if (isZero(ctx.expr())) {
                write = new Instruction.WriteInst(REG0, MemAddr.DirAddr, offset2String(offset(ctx.ID(), true), true));
            } else {
                write = new Instruction.WriteInst(getReg(ctx.expr()), MemAddr.DirAddr, offset2String(offset(ctx.ID(), true), true));
            }
            addInstr(write);

            emptyReg(ctx.expr());
        }

        setCodeLines(ctx, lines + 1);
        return null;
    }

    @Override
    public String visitVarDeclStat(GuavaParser.VarDeclStatContext ctx) {
        int lines = 0;

        if (ctx.expr() != null) {
            visit(ctx.expr());
            lines += getCodeLines(ctx.expr());

            Instruction store;
            if (isZero(ctx.expr())) {
                store = new Instruction.Store(REG0, MemAddr.DirAddr, offset2String(offset(ctx.ID(), false), false));
            } else {
                store = new Instruction.Store(getReg(ctx.expr()), MemAddr.DirAddr, offset2String(offset(ctx.ID(), false), false));
            }
            addInstr(store);

            emptyReg(ctx.expr());
        }

        setCodeLines(ctx, lines + 1);
        return null;
    }

    @Override
    public String visitArrayDeclStat(GuavaParser.ArrayDeclStatContext ctx) {
        int lines = 0;
        Instruction store;

        if (ctx.expr() != null) {
            visit(ctx.expr());
            lines += getCodeLines(ctx.expr());

            List<String> regs = this.arrayValues.get(ctx.expr());

            for (int i = 0; i < regs.size(); i++) {
                store = new Instruction.Store(regs.get(i), MemAddr.DirAddr, "(" + offset2String(offset(ctx.ID(), false), false) + " + " + i + ")");
                addInstr(store);

                lines++;
            }

            for (int i = regs.size() - 1; i >= 0; i--) {
                emptyReg(regs.get(i));
            }
        }

        setCodeLines(ctx, lines);
        return null;
    }

    @Override
    public String visitAssignStat(GuavaParser.AssignStatContext ctx) {
        int lines = 0;

        visit(ctx.expr());
        lines += getCodeLines(ctx.expr());

        Instruction store;
        if (result.getType(ctx.expr()).getKind() == PrimitiveTypes.ARRAY) {
            List<String> regs = this.arrayValues.get(ctx.expr());

            for (int i = 0; i < regs.size(); i++) {
                store = new Instruction.Store(regs.get(i), MemAddr.DirAddr, "(" + offset2String(offset(ctx.ID(), false), false) + " + " + i + ")");
                addInstr(store);

                lines++;
            }

            for (int i = regs.size() - 1; i > 0; i--) {
                emptyReg(regs.get(i));
            }

        } else {
            String getReg;

            if (isZero(ctx.expr())) {
                getReg = REG0;
            } else {
                getReg = getReg(ctx.expr());
            }

            if (result.isGlobalVar(ctx.ID())) {
                store = new Instruction.WriteInst(getReg, MemAddr.DirAddr, offset2String(offset(ctx.ID(), true), true));
            } else {
                store = new Instruction.Store(getReg, MemAddr.DirAddr, offset2String(offset(ctx.ID(), false), false));
            }

            lines++;
            addInstr(store);
        }

        setCodeLines(ctx, lines);

        emptyReg(ctx.expr());
        releaseLoadedVariables();
        return null;
    }

    @Override
    public String visitAssignArrayStat(GuavaParser.AssignArrayStatContext ctx) {
        int lines = 0;

        visit(ctx.expr());
        lines += getCodeLines(ctx.expr());

        Instruction store = new Instruction.Store(getReg(ctx.expr()), MemAddr.DirAddr, getReg(ctx));
        addInstr(store);

        lines += 1;

        setCodeLines(ctx, lines);
        emptyReg(getReg(ctx.expr()));
        return null;
    }

    @Override
    public String visitIfStat(GuavaParser.IfStatContext ctx) {
        int lines = 0;

        visit(ctx.expr());
        lines += getCodeLines(ctx.expr());

        if (ctx.ELSE() == null) {
            addInstr(new Instruction.Branch(getReg(ctx.expr()), Target.Rel, "2"));

            // We want to insert a relative jump instruction on this index later on.
            int index = reserveInstr();

            visit(ctx.stat(0));
            int jump = getCodeLines(ctx.stat(0)) + 1;
            lines += jump;
            addInstr(new Instruction.Jump(Target.Rel, "" + jump), index);
            lines += 2;
        } else {
            addInstr(new Instruction.Branch(getReg(ctx.expr()), Target.Rel, "2"));

            // We want to insert a relative jump instruction on this index later on.
            int ifJump = reserveInstr();
            visit(ctx.stat(0));

            // We want to insert a relative jump instruction on this index later on.
            int elseJump = reserveInstr();
            visit(ctx.stat(1));

            // We need to jump over all the generated code (hence + 1) and over the extra jump instruction (hence another +1).
            int jump0 = getCodeLines(ctx.stat(0)) + 2;

            // We need to jump over all the generated code.
            int jump1 = getCodeLines(ctx.stat(1)) + 1;

            addInstr(new Instruction.Jump(Target.Rel, "" + jump0), ifJump);
            addInstr(new Instruction.Jump(Target.Rel, "" + jump1), elseJump);

            lines += getCodeLines(ctx.stat(0));
            lines += getCodeLines(ctx.stat(1));
            lines += 3;
        }

        setCodeLines(ctx, lines);
        return null;
    }

    @Override
    public String visitBlockStat(GuavaParser.BlockStatContext ctx) {
        int lines = 0;

        visitChildren(ctx);

        for (int i = 0; i < ctx.stat().size(); i++) {
            lines += getCodeLines(ctx.stat(i));
        }

        setCodeLines(ctx, lines);
        return null;
    }

    @Override
    public String visitWhileStat(GuavaParser.WhileStatContext ctx) {
        int lines = 0;

        visit(ctx.expr());
        lines += getCodeLines(ctx.expr());

        addInstr(new Instruction.Branch(getReg(ctx.expr()), Target.Rel, "2"));
        int index = reserveInstr();

        visit(ctx.stat());
        int jump = getCodeLines(ctx.stat()) + 2;
        lines += getCodeLines(ctx.stat());

        addInstr(new Instruction.Jump(Target.Rel, "" + jump), index);
        lines += 2;
        addInstr(new Instruction.Jump(Target.Rel, "(-" + lines + ")"));
        lines++;

        setCodeLines(ctx, lines);
        return null;
    }

    @Override
    public String visitForStat(GuavaParser.ForStatContext ctx) {
        int lines = 0;

        visit(ctx.forAss());
        lines += getCodeLines(ctx.forAss());

        nested = true;
        visit(ctx.expr(0));
        nested = false;

        lines += getCodeLines(ctx.expr(0));

        addInstr(new Instruction.Branch(getReg(ctx.expr(0)), Target.Rel, "2"));
        lines++;

        int index = reserveInstr();

        visit(ctx.stat());
        lines += getCodeLines(ctx.stat());

        int jump = getCodeLines(ctx.stat()) + 3;
        addInstr(new Instruction.Jump(Target.Rel, "" + jump), index);
        lines++;
        int add = 0;
        if (ctx.expr().size() > 1) {
            visit(ctx.expr(1));
            lines += getCodeLines(ctx.expr(1));
            add = getCodeLines(ctx.expr(1));
        } else if (ctx.PLUS() != null) {
            addInstr(new Instruction.Compute(Op.Incr, getNestedVarReg(ctx.ID()), REG0, getNestedVarReg(ctx.ID())));
            lines++;
            add = 1;
        } else if (ctx.MINUS() != null) {
            addInstr(new Instruction.Compute(Op.Decr, getNestedVarReg(ctx.ID()), REG0, getNestedVarReg(ctx.ID())));
            lines++;
            add = 1;
        }

        jump = getCodeLines(ctx.stat()) + 3 + add;
        addInstr(new Instruction.Jump(Target.Rel, "(-" + jump + ")"));
        lines++;

        setCodeLines(ctx, lines);

        emptyReg(ctx.expr(0));
        delNestedVar(ctx.ID());
        return null;
    }

    @Override
    public String visitPrintStat(GuavaParser.PrintStatContext ctx) {
        return null;
    }

    // Expressions -----------------------------------------------------------------------------------------------------
    @Override
    public String visitPrfExpr(GuavaParser.PrfExprContext ctx) {
        int lines = 0;
        visit(ctx.expr());

        lines += getCodeLines(ctx.expr());

        String getReg = getReg(ctx.expr());

        Instruction load;
        Instruction neg;
        if (result.getType(ctx.expr()) == Type.BOOL) {
            load = new Instruction.Load(MemAddr.ImmValue, String.valueOf(1), getReg(ctx));
            neg = new Instruction.Compute(Op.Xor, getReg, getReg(ctx), getReg(ctx));
        } else {
            load = new Instruction.Load(MemAddr.ImmValue, "(-1)", getReg(ctx));
            neg = new Instruction.Compute(Op.Mul, getReg, getReg(ctx), getReg(ctx));
        }

        addInstr(load);
        addInstr(neg);
        setCodeLines(ctx, lines + 1);

        emptyReg(ctx.expr());
        return DIR;
    }

    @Override
    public String visitMultExpr(GuavaParser.MultExprContext ctx) {
        int lines = 0;
        visit(ctx.expr(0));
        visit(ctx.expr(1));

        String reg1 = getReg(ctx.expr(0));
        String reg2 = getReg(ctx.expr(1));

        if (isZero(ctx.expr(0))) {
            reg1 = REG0;
            emptyReg(ctx.expr(0));
        } else {
            lines += getCodeLines(ctx.expr(0));
        }

        if (isZero(ctx.expr(1))) {
            reg2 = REG0;
            emptyReg(ctx.expr(1));
        } else {
            lines += getCodeLines(ctx.expr(1));
        }

        Instruction mult = null;

        switch (ctx.multOp().getText()) {
            case "*":
                mult = new Instruction.Compute(Op.Mul, reg1, reg2, getReg(ctx));
                break;
            case "/":
                mult = new Instruction.Compute(Op.Div, reg1, reg2, getReg(ctx));
                break;
            case "^":
                mult = new Instruction.Compute(Op.Pow, reg1, reg2, getReg(ctx));
                break;
        }

        addInstr(mult);
        setCodeLines(ctx, lines + 1);

        emptyReg(ctx.expr(1));
        emptyReg(ctx.expr(0));
        return DIR;
    }

    @Override
    public String visitPlusExpr(GuavaParser.PlusExprContext ctx) {
        int lines = 0;
        visit(ctx.expr(0));
        visit(ctx.expr(1));

        String reg1 = getReg(ctx.expr(0));
        String reg2 = getReg(ctx.expr(1));

        if (isZero(ctx.expr(0))) {
            reg1 = REG0;
            emptyReg(ctx.expr(0));
        } else {
            lines += getCodeLines(ctx.expr(0));
        }

        if (isZero(ctx.expr(1))) {
            reg2 = REG0;
            emptyReg(ctx.expr(1));
        } else {
            lines += getCodeLines(ctx.expr(1));
        }

        Instruction plus = null;

        switch (ctx.plusOp().getText()) {
            case "+":
                plus = new Instruction.Compute(Op.Add, reg1, reg2, getReg(ctx));
                break;
            case "-":
                plus = new Instruction.Compute(Op.Sub, reg1, reg2, getReg(ctx));
                break;
        }

        addInstr(plus);
        setCodeLines(ctx, lines + 1);

        emptyReg(ctx.expr(1));
        emptyReg(ctx.expr(0));
        return DIR;
    }

    @Override
    public String visitBoolExpr(GuavaParser.BoolExprContext ctx) {
        int lines = 0;
        visit(ctx.expr(0));
        visit(ctx.expr(1));

        String reg1 = getReg(ctx.expr(0));
        String reg2 = getReg(ctx.expr(1));

        if (isZero(ctx.expr(0))) {
            reg1 = REG0;
            emptyReg(ctx.expr(0));
        } else {
            lines += getCodeLines(ctx.expr(0));
        }

        if (isZero(ctx.expr(1))) {
            reg2 = REG0;
            emptyReg(ctx.expr(1));
        } else {
            lines += getCodeLines(ctx.expr(1));
        }

        Instruction bool = null;

        switch (ctx.boolOp().getText()) {
            case "&":
                bool = new Instruction.Compute(Op.And, reg1, reg2, getReg(ctx));
                break;
            case "|":
                bool = new Instruction.Compute(Op.Or, reg1, reg2, getReg(ctx));
                break;
        }

        addInstr(bool);
        setCodeLines(ctx, lines + 1);

        emptyReg(ctx.expr(1));
        emptyReg(ctx.expr(0));
        return DIR;
    }

    @Override
    public String visitCompExpr(GuavaParser.CompExprContext ctx) {
        int lines = 0;
        visit(ctx.expr(0));
        visit(ctx.expr(1));

        String reg1 = getReg(ctx.expr(0));
        String reg2 = getReg(ctx.expr(1));

        if (isZero(ctx.expr(0))) {
            reg1 = REG0;
            emptyReg(ctx.expr(0));
        } else {
            lines += getCodeLines(ctx.expr(0));
        }

        if (isZero(ctx.expr(1))) {
            reg2 = REG0;
            emptyReg(ctx.expr(1));
        } else {
            lines += getCodeLines(ctx.expr(1));
        }

        Instruction compute = null;

        switch (ctx.compOp().getText()) {
            case ">":
                compute = new Instruction.Compute(Op.Gt, reg1, reg2, getReg(ctx));
                break;
            case ">=":
                compute = new Instruction.Compute(Op.GtE, reg1, reg2, getReg(ctx));
                break;
            case "<":
                compute = new Instruction.Compute(Op.Lt, reg1, reg2, getReg(ctx));
                break;
            case "<=":
                compute = new Instruction.Compute(Op.LtE, reg1, reg2, getReg(ctx));
                break;
            case "~=":
                compute = new Instruction.Compute(Op.NEq, reg1, reg2, getReg(ctx));
                break;
            case "==":
                compute = new Instruction.Compute(Op.Equal, reg1, reg2, getReg(ctx));
                break;
        }

        addInstr(compute);
        setCodeLines(ctx, lines + 1);

        emptyReg(ctx.expr(1));
        emptyReg(ctx.expr(0));
        return DIR;
    }

    @Override
    public String visitParExpr(GuavaParser.ParExprContext ctx) {
        visit(ctx.expr());
        setCodeLines(ctx, getCodeLines(ctx.expr()));
        return DIR;
    }

    @Override
    public String visitArrayExpr(GuavaParser.ArrayExprContext ctx) {
        int lines = 0;

        List<String> regs = new ArrayList<>();

        for (int i = 0; i < ctx.expr().size(); i++) {
            visit(ctx.expr(i));
            lines += getCodeLines(ctx.expr(i));
            regs.add(getReg(ctx.expr(i)));
        }

        this.arrayValues.put(ctx, regs);
        setCodeLines(ctx, lines);
        return DIR;
    }

    @Override
    public String visitConstExpr(GuavaParser.ConstExprContext ctx) {
        Instruction load = null;
        int lines = 0;

        switch (result.getType(ctx).getKind()) {
            case INT:
                load = new Instruction.LoadConst(ctx.getText(), getReg(ctx));
                break;
            case BOOL:
                if (ctx.getText().equals("sweet")) {
                    load = new Instruction.LoadConst(TRUE, getReg(ctx));
                } else {
                    load = new Instruction.LoadConst(FALSE, getReg(ctx));
                }

                break;
            case CHAR:
                String ch = ctx.getText().replaceAll("'", "");
                char c = ch.charAt(0);
                int i = (int) c;

                load = new Instruction.LoadConst(String.valueOf(i), getReg(ctx));

                break;
        }

        if (!isZero(ctx)) {
            addInstr(load);
            lines++;
        }

        setCodeLines(ctx, lines);
        return CONST;
    }

    @Override
    public String visitGetArrayExpr(GuavaParser.GetArrayExprContext ctx) {
        int lines = 0;
        Instruction load = new Instruction.Load(MemAddr.DirAddr, "(" + offset2String(offset(ctx.ID(), false), false)
                + " + " + ctx.NUM().getText() + ")", getReg(ctx));
        lines++;

        addInstr(load);
        setCodeLines(ctx, lines);
        return DIR;
    }

    @Override
    public String visitIdExpr(GuavaParser.IdExprContext ctx) {
        Instruction load = null;
        Instruction receive = null;
        int lines = 0;

        if (result.isGlobalVar(ctx.ID())) {
            load = new Instruction.ReadInstr(MemAddr.DirAddr, offset2String(offset(ctx, true), true));
            receive = new Instruction.Receive(getReg(ctx));
        } else {
            if (!isNestedVar(ctx.ID())) {
                load = new Instruction.Load(MemAddr.DirAddr, offset2String(offset(ctx.ID(), false), false), getReg(ctx));
            }
        }

        if (load != null && !isLoadedVariable(ctx.ID())) {
            addInstr(load);
            loadVariable(ctx.ID(), getReg(ctx));
            lines += 1;
        }

        if (receive != null && !isLoadedVariable(ctx.ID())) {
            addInstr(receive);
            loadVariable(ctx.ID(), getReg(ctx));
            lines += 1;
        }

        setCodeLines(ctx, lines);
        return DIR;
    }

    // For loop declarations -------------------------------------------------------------------------------------------
    @Override
    public String visitForDecl(GuavaParser.ForDeclContext ctx) {
        int lines = 0;
        if (ctx.expr() != null) {
            visit(ctx.expr());
            lines += getCodeLines(ctx.expr());
        }

        addNestedVar(ctx.ID(), getReg(ctx.expr()));
        setCodeLines(ctx, lines);
        return null;
    }

    @Override
    public String visitForExisting(GuavaParser.ForExistingContext ctx) {
        setCodeLines(ctx, 0);
        return null;
    }

    // Auxiliary functions ---------------------------------------------------------------------------------------------
    /**
     * Adds a new instruction to the program
     * @param instr the instruction to add
     */
    private void addInstr(Instruction instr) {
        this.instructions.add(instr.toString());
    }

    /**
     * Inserts an instruction into the program at a given index (line)
     * @param instr the instruction to insert
     * @param index the index to insert the instruction at
     */
    private void addInstr(Instruction instr, int index) {
        this.instructions.remove(index);
        this.instructions.add(index, instr.toString());
    }

    /**
     * Reserves an instruction slot that will be filled later (e.g. in case of relative jumps)
     * @return the index of the reserved instruction
     */
    private int reserveInstr() {
        this.instructions.add("RESERVED");
        return this.instructions.size() - 1;
    }

    /**
     * Adds a nested variable
     * @param node the node containing the variable to add
     * @param reg register in which the nested variable is saved
     */
    private void addNestedVar(ParseTree node, String reg) {
        if (!isNestedVar(node)) {
            this.nestedVars.put(node.getText(), reg);
        }
    }

    /**
     * Removes a nested variable
     * @param node the node containing the variable to remove
     */
    private void delNestedVar(ParseTree node) {
        if (this.nestedVars.containsKey(node.getText())) {
            this.nestedVars.remove(node.getText());
        }
    }

    /**
     * Checks whether a variable is a nested variable
     * @param node the node containing the variable to check
     * @return <tt>true</tt> if the given variable is nested inside a loop declaration
     */
    private boolean isNestedVar(ParseTree node) {
        return this.nestedVars.containsKey(node.getText());
    }

    /**
     * Returns the register in which a nested variable is stored
     * @param node the node containing the variable
     * @return the register in which the given variable is stored
     */
    private String getNestedVarReg(ParseTree node) {
        return this.nestedVars.get(node.getText());
    }

    /**
     * Returns the offset of a variable, calculated in the Checker
     * @param node the node containing the variable of which the offset is requested
     * @param global if a variable is global (universal), it is stored in a different location
     * @return the offset of the given variable, either in local or shared memory
     */
    private String offset(ParseTree node, boolean global) {
        return this.result.getOffset(node, global);
    }

    /**
     * Empties a register. While a for loop is being executed, registers cannot be emptied to ensure correct
     * loop behaviour.
     * @param node the node currently stored in the register to empty
     */
    private void emptyReg(ParseTree node) {
        emptyReg(getReg(node));
    }

    /**
     * Empties a register. While a for loop is being executed, registers cannot be emptied to ensure correct
     * loop behaviour.
     * @param reg the register to empty
     */
    private void emptyReg(String reg) {
        if (!nested) {
            this.emptyRegisters.add(0, reg);
        }
    }

    /**
     * Returns the register in which the given variable is stored. First it checks if the given variable is a nested
     * variable, else it checks if the variable is already loaded from local memory. If both are not the case, it
     * searches for the variable in the register bank and appoints a new register if necessary.
     * @param node the node containing the variable of which the register is requested
     * @return the register in which the given variable is stored
     */
    private String getReg(ParseTree node) {
        String reg;
        if (isNestedVar(node)) {
            reg = getNestedVarReg(node);
        } else if (isLoadedVariable(node)){
            reg = getLoadedVariable(node);
        } else {
            reg = reg(node);
        }

        return reg;
    }

    /**
     * If a variable is not appointed a register yet, it will create a new register for that node. Otherwise it returns
     * the register in which the variable is stored
     * @param node the node containing the variable of which the register is requested
     * @return the register in which the given variable is stored
     */
    private String reg(ParseTree node) {
        if (this.registers.get(node) != null) {
            return this.registers.get(node);
        } else {
            this.registers.put(node, emptyRegisters.remove(0));
            return this.registers.get(node);
        }
    }

    /**
     * Load a variable from local memory into a register
     * @param node the node containing the variable to load
     * @param reg the register in which the loaded variable is stored
     */
    private void loadVariable(ParseTree node, String reg) {
        if (!isLoadedVariable(node)) {
            this.loadedVariables.put(node.getText(), reg);
        }
    }

    /**
     * Checks whether a variable is loaded into a register
     * @param node the node containing the variable to check
     * @return <tt>true</tt> if the variable is currently stored in a register
     */
    private boolean isLoadedVariable(ParseTree node) {
        return this.loadedVariables.containsKey(node.getText());
    }

    /**
     * Returns the register in which the given variable is loaded
     * @param node the node containing the variable of which the register is requested
     * @return the register in which the given variable is loaded
     */
    private String getLoadedVariable(ParseTree node) {
        return this.loadedVariables.get(node.getText());
    }

    /**
     * Unloads all loaded variables
     */
    private void releaseLoadedVariables() {
        this.loadedVariables = new HashMap<>();
    }

    /**
     * Returns how many Sprockell instructions a certain node will generate
     * @param node the node for which the amount of instructions is requested
     * @return the number of Sprockell instructions a certain node will generate
     */
    private int getCodeLines(ParseTree node) {
        return this.codeLines.get(node);
    }

    /**
     * Sets how many Sprockell instructions a certain node will generate
     * @param node the node for which the amount of instructions is set
     * @param i the number of instructions generated by this node
     */
    private void setCodeLines(ParseTree node, int i) {
        this.codeLines.put(node, i);
    }

    /**
     * Checks whether a variable equals <tt>0</tt>
     * @param node the node containing the variable to check
     * @return <tt>true</tt> if the given variable equals <tt>0</tt>
     */
    private boolean isZero(ParseTree node) {
        return node.getText().equals("0");
    }

    /**
     * Translates an offset to a variable name, as defined in the list of variables that is generated alongside the
     * Sprockell instructions
     * @param offset the offset for which the variable name will be returned
     * @param global indicates whether the offset is defined as global or not
     * @return the name of the variable belonging to the given offset
     */
    private String offset2String(String offset, boolean global) {
        if (global) {
            return this.result.getGlobalVarMap().get(Integer.parseInt(offset));
        } else {
            return this.result.getVarMap().get(Integer.parseInt(offset));
        }
    }
}
