package elaboration;

import grammar.GuavaBaseVisitor;
import grammar.GuavaParser;
import spril.MemAddr;
import spril.Op;
import spril.Instruction;
import spril.Target;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeProperty;
import org.junit.Assert;

import java.util.*;

/**
 * Created by Jens on 14-6-2016.
 *
 */
public class GuavaGenerator extends GuavaBaseVisitor<String> {
    /** This is the result of the checking phase.*/
    private CheckerResult result;

    /** This is the list with operations which will be filled during the code generation.*/
    private List<String> operations;

    /** The ParseTreeProperty and Map are used for register allocation and retrieval of registers for certain nodes.*/
    private ParseTreeProperty<String> registers;

    /** This is a list of all registers which can be overwritten.*/
    private List<String> emptyRegisters;

    private ParseTreeProperty<ParserRuleContext> next;

    /** This ParseTreeProperty is used to store the number of lines generated by each specific ParseTree.
     *  This is used to determine where to jump to in the if, while and for statements.*/
    private ParseTreeProperty<Integer> codeLines;

    /** Variables declared in for-loops will be stored here. These variables are saved and handled entirely in
     *  registers, to speed up execution*/
    private Map<String, String> nestedVars;

    private Map<String, String> loadedVariables;

    /** Will be set to true when a for-loop declaration is entered, to ensure some registers do not get emptied*/
    private boolean nested;

    private static ParserRuleContext END;

    private static final String CONST = "CONST";
    private static final String DIR = "DIR";
    private static final String REG0 = "reg0";
    private static final String TRUE = "1";
    private static final String FALSE = "0";

    public GuavaGenerator(ParseTree tree, CheckerResult result, String[] availableRegs) {
        Assert.assertTrue(result != null);
        this.result = result;
        operations = new ArrayList<>();
        registers = new ParseTreeProperty<>();
        next = new ParseTreeProperty<>();
        codeLines = new ParseTreeProperty<>();
        nestedVars = new HashMap<>();
        loadedVariables = new HashMap<>();
        nested = false;
        emptyRegisters = new ArrayList<>();
        Collections.addAll(emptyRegisters, availableRegs);
        tree.accept(this);
    }

    /** Get the list of all operations.*/
    public List<String> getOperations() {
        return this.operations;
    }

    /** Start of the program. */
    @Override
    public String visitProgram(GuavaParser.ProgramContext ctx) {
        END = ctx;
        visitChildren(ctx);
        addOp(new Instruction.EndProg());
        return null;
    }

    /** Body of the program. */
    @Override
    public String visitBody(GuavaParser.BodyContext ctx) {
        for (int i = 0; i < ctx.global().size() - 1; i++) {
            setNext(ctx.global(i), result.getEntry(ctx.global(i + 1)));
        }

        setNext(ctx.global(ctx.global().size() - 1), ctx.stat(0));

        for (int i = 0; i < ctx.stat().size() - 1; i++) {
            setNext(ctx.stat(i), result.getEntry(ctx.stat(i + 1)));
        }

        setNext(ctx.stat(ctx.stat().size() - 1), END);
        visitChildren(ctx);
        return null;
    }

    @Override
    public String visitGlobalDecl(GuavaParser.GlobalDeclContext ctx) {
        int lines = 0;

        if (ctx.expr() != null) {
            visit(ctx.expr());
            lines += getCodeLines(ctx.expr());
            Instruction write = new Instruction.WriteInst(reg(ctx.expr()), MemAddr.DirAddr, offset2String(offset(ctx.ID())));
            addOp(write);
            emptyReg(ctx.expr());
        }

        setCodeLines(ctx, lines + 1);
        return null;
    }

    /** All stats of the program. */
    @Override
    public String visitVarDeclStat(GuavaParser.VarDeclStatContext ctx) {
        int lines = 0;

        if (ctx.expr() != null) {
            visit(ctx.expr());
            lines += getCodeLines(ctx.expr());
            Instruction store = new Instruction.Store(reg(ctx.expr()), MemAddr.DirAddr, offset2String(offset(ctx.ID())));
            addOp(store);
            emptyReg(ctx.expr());
        }

        setCodeLines(ctx, lines + 1);
        return null;
    }

    @Override
    public String visitArrayDeclStat(GuavaParser.ArrayDeclStatContext ctx) {
        //@TODO implement storage of arrays
        return null;
    }

    @Override
    public String visitAssignStat(GuavaParser.AssignStatContext ctx) {
        int lines = 0;
        visit(ctx.expr());

        Instruction store;
        if (result.isGlobalVar(ctx.ID())) {
            store = new Instruction.WriteInst(reg(ctx.expr()), MemAddr.DirAddr, offset2String(offset(ctx.ID())));
        } else {
            store = new Instruction.Store(reg(ctx.expr()), MemAddr.DirAddr, offset2String(offset(ctx.ID())));
        }

        addOp(store);

        lines += getCodeLines(ctx.expr());
        setCodeLines(ctx, lines + 1);

        emptyReg(ctx.expr());
        releaseLoadedVariables();
        return null;
    }

    @Override
    public String visitIfStat(GuavaParser.IfStatContext ctx) {
        int lines = 0;
        visit(ctx.expr());
        lines += getCodeLines(ctx.expr());

        if (ctx.ELSE() == null) {
            addOp(new Instruction.Branch(reg(ctx.expr()), Target.Rel, "2"));
            int index = reserveOp();        // We want to insert a relative jump instruction on this index later on.
            visit(ctx.stat(0));
            int jump = getCodeLines(ctx.stat(0)) + 1;
            lines += jump;
            addOp(new Instruction.Jump(Target.Rel, "" + jump), index);
            lines += 2;
        } else {
            addOp(new Instruction.Branch(reg(ctx.expr()), Target.Rel, "2"));

            int ifJump = reserveOp();       // We want to insert a relative jump instruction on this index later on.
            visit(ctx.stat(0));
            int elseJump = reserveOp();     // We want to insert a relative jump instruction on this index later on.
            visit(ctx.stat(1));

            int jump0 = getCodeLines(ctx.stat(0)) + 2;      // We need to jump over all the generated code (hence + 1) and over the extra jump instruction (hence another +1).
            int jump1 = getCodeLines(ctx.stat(1)) + 1;      // We need to jump over all the generated code.

            addOp(new Instruction.Jump(Target.Rel, "" + jump0), ifJump);
            addOp(new Instruction.Jump(Target.Rel, "" + jump1), elseJump);

            lines += getCodeLines(ctx.stat(0));
            lines += getCodeLines(ctx.stat(1));
            lines += 3;
        }

        setCodeLines(ctx, lines);
        return null;
    }

    @Override
    public String visitBlockStat(GuavaParser.BlockStatContext ctx) {
        int lines = 0;

        for (int i = 0; i < ctx.stat().size() - 1; i++) {
            if (i == ctx.stat().size() - 1) {
                setNext(ctx.stat(i), getNext(ctx));
            } else {
                setNext(ctx.stat(i), result.getEntry(ctx.stat(i + 1)));
            }
        }

        visitChildren(ctx);

        for (int i = 0; i < ctx.stat().size(); i++) {
            lines += getCodeLines(ctx.stat(i));
        }

        setCodeLines(ctx, lines);
        return null;
    }

    @Override
    public String visitWhileStat(GuavaParser.WhileStatContext ctx) {
        int lines = 0;
        visit(ctx.expr());
        lines += getCodeLines(ctx.expr());

        addOp(new Instruction.Branch(reg(ctx.expr()), Target.Rel, "2"));
        int index = reserveOp();

        visit(ctx.stat());
        int jump = getCodeLines(ctx.stat()) + 2;
        lines += getCodeLines(ctx.stat());

        addOp(new Instruction.Jump(Target.Rel, "" + jump), index);
        lines += 2;
        addOp(new Instruction.Jump(Target.Rel, "(-" + lines + ")"));
        lines++;

        setCodeLines(ctx, lines);
        return null;
    }

    @Override
    public String visitForStat(GuavaParser.ForStatContext ctx) {
        int lines = 0;
        visit(ctx.forAss());
        lines += getCodeLines(ctx.forAss());

        nested = true;
        visit(ctx.expr(0));
        nested = false;
        lines += getCodeLines(ctx.expr(0));

        addOp(new Instruction.Branch(reg(ctx.expr(0)), Target.Rel, "2"));
        lines++;

        int index = reserveOp();
        visit(ctx.stat());
        lines += getCodeLines(ctx.stat());

        int jump = getCodeLines(ctx.stat()) + 3;
        addOp(new Instruction.Jump(Target.Rel, "" + jump), index);
        lines++;
        int add = 0;
        if (ctx.expr().size() > 1) {
            visit(ctx.expr(1));
            lines += getCodeLines(ctx.expr(1));
            add = getCodeLines(ctx.expr(1));
        } else if (ctx.PLUS() != null) {
            addOp(new Instruction.Compute(Op.Incr, getNestedVarReg(ctx.ID()), REG0, getNestedVarReg(ctx.ID())));
            lines++;
            add = 1;
        } else if (ctx.MINUS() != null) {
            addOp(new Instruction.Compute(Op.Decr, getNestedVarReg(ctx.ID()), REG0, getNestedVarReg(ctx.ID())));
            lines++;
            add = 1;
        }

        jump = getCodeLines(ctx.stat()) + 3 + add;
        addOp(new Instruction.Jump(Target.Rel, "(-" + jump + ")"));

        setCodeLines(ctx, lines);

        emptyReg(ctx.expr(0));
        delNestedVar(ctx.ID());
        return null;
    }

    @Override
    public String visitPrintStat(GuavaParser.PrintStatContext ctx) {
        return null;
    }

    @Override
    public String visitForkStat(GuavaParser.ForkStatContext ctx) {
        for (int i = 0; i < ctx.stat().size()-1; i++) {
            if (i == ctx.stat().size() -1) {
                setNext(ctx.stat(i), getNext(ctx));
            } else {
                setNext(ctx.stat(i), result.getEntry(ctx.stat(i + 1)));
            }
        }
        int lines = 0;
        visitChildren(ctx);
        for (int i = 0; i < ctx.stat().size(); i++) {
            lines += getCodeLines(ctx.stat(i));
        }
        setCodeLines(ctx, lines);
        return null;
    }

    @Override
    public String visitJoinStat(GuavaParser.JoinStatContext ctx) {
        return null;
    }

    /** All expressions. */
    @Override
    public String visitPrfExpr(GuavaParser.PrfExprContext ctx) {
        setNext(ctx.expr(), getNext(ctx));
        int lines = 0;
        visit(ctx.expr());

        lines += getCodeLines(ctx.expr());

        String reg = getReg(ctx.expr());

        Instruction load;
        Instruction neg;
        if (result.getType(ctx.expr()) == Type.BOOL) {
            load = new Instruction.Load(MemAddr.ImmValue, String.valueOf(1), reg(ctx));
            neg = new Instruction.Compute(Op.Xor, reg, reg(ctx), reg(ctx));
        } else {
            load = new Instruction.Load(MemAddr.ImmValue, "(-1)", reg(ctx));
            neg = new Instruction.Compute(Op.Mul, reg, reg(ctx), reg(ctx));
        }

        addOp(load);
        addOp(neg);
        setCodeLines(ctx, lines + 1);

        emptyReg(ctx.expr());
        return DIR;
    }

    @Override
    public String visitMultExpr(GuavaParser.MultExprContext ctx) {
        int lines = 0;
        visit(ctx.expr(0));
        visit(ctx.expr(1));

        lines += getCodeLines(ctx.expr(0));
        lines += getCodeLines(ctx.expr(1));

        String reg1 = getReg(ctx.expr(0));
        String reg2 = getReg(ctx.expr(1));

        if (isZero(ctx.expr(0))) {
            reg1 = REG0;
            emptyReg(ctx.expr(0));
        }

        if (isZero(ctx.expr(1))) {
            reg2 = REG0;
            emptyReg(ctx.expr(1));
        }

        Instruction mult;

        switch (ctx.multOp().getText()) {
            case "*":
                mult = new Instruction.Compute(Op.Mul, reg1, reg2, reg(ctx));
                break;
            case "/":
                mult = new Instruction.Compute(Op.Div, reg1, reg2, reg(ctx));
                break;
            case "^":
                mult = new Instruction.Compute(Op.Pow, reg1, reg2, reg(ctx));
                break;
            default:
                // This should never be reached
                mult = new Instruction.Compute(Op.Mul, reg1, reg2, reg(ctx));
                break;
        }

        addOp(mult);
        setCodeLines(ctx, lines + 1);

        emptyReg(ctx.expr(1));
        emptyReg(ctx.expr(0));
        return DIR;
    }

    @Override
    public String visitPlusExpr(GuavaParser.PlusExprContext ctx) {
        int lines = 0;
        visit(ctx.expr(0));
        visit(ctx.expr(1));

        lines += getCodeLines(ctx.expr(0));
        lines += getCodeLines(ctx.expr(1));

        String reg1 = getReg(ctx.expr(0));
        String reg2 = getReg(ctx.expr(1));

        if (isZero(ctx.expr(0))) {
            reg1 = REG0;
            emptyReg(ctx.expr(0));
        }

        if (isZero(ctx.expr(1))) {
            reg2 = REG0;
            emptyReg(ctx.expr(1));
        }

        Instruction plus;

        switch (ctx.plusOp().getText()) {
            case "+":
                plus = new Instruction.Compute(Op.Add, reg1, reg2, reg(ctx));
                break;
            case "-":
                plus = new Instruction.Compute(Op.Sub, reg1, reg2, reg(ctx));
                break;
            default:
                // This should never be reached
                plus = new Instruction.Compute(Op.Add, reg1, reg2, reg(ctx));
                break;
        }

        addOp(plus);
        setCodeLines(ctx, lines + 1);

        emptyReg(ctx.expr(1));
        emptyReg(ctx.expr(0));
        return DIR;
    }

    @Override
    public String visitBoolExpr(GuavaParser.BoolExprContext ctx) {
        int lines = 0;
        visit(ctx.expr(0));
        visit(ctx.expr(1));

        lines += getCodeLines(ctx.expr(0));
        lines += getCodeLines(ctx.expr(1));

        String reg1 = getReg(ctx.expr(0));
        String reg2 = getReg(ctx.expr(1));

        if (isZero(ctx.expr(0))) {
            reg1 = REG0;
            emptyReg(ctx.expr(0));
        }

        if (isZero(ctx.expr(1))) {
            reg2 = REG0;
            emptyReg(ctx.expr(1));
        }

        Instruction bool;

        switch (ctx.boolOp().getText()) {
            case "&":
                bool = new Instruction.Compute(Op.And, reg1, reg2, reg(ctx));
                break;
            case "|":
                bool = new Instruction.Compute(Op.Or, reg1, reg2, reg(ctx));
                break;
            default:
                // This should never be reached
                bool = new Instruction.Compute(Op.And, reg1, reg2, reg(ctx));
                break;
        }

        addOp(bool);
        setCodeLines(ctx, lines + 1);

        emptyReg(ctx.expr(1));
        emptyReg(ctx.expr(0));
        return DIR;
    }

    @Override
    public String visitCompExpr(GuavaParser.CompExprContext ctx) {
        int lines = 0;
        visit(ctx.expr(0));
        visit(ctx.expr(1));

        lines += getCodeLines(ctx.expr(0));
        lines += getCodeLines(ctx.expr(1));

        String reg1 = getReg(ctx.expr(0));
        String reg2 = getReg(ctx.expr(1));

        if (isZero(ctx.expr(0))) {
            reg1 = REG0;
            emptyReg(ctx.expr(0));
        }

        if (isZero(ctx.expr(1))) {
            reg2 = REG0;
            emptyReg(ctx.expr(1));
        }

        Instruction compute;

        switch (ctx.compOp().getText()) {
            case ">":
                compute = new Instruction.Compute(Op.Gt, reg1, reg2, reg(ctx));
                break;
            case ">=":
                compute = new Instruction.Compute(Op.GtE, reg1, reg2, reg(ctx));
                break;
            case "<":
                compute = new Instruction.Compute(Op.Lt, reg1, reg2, reg(ctx));
                break;
            case "<=":
                compute = new Instruction.Compute(Op.LtE, reg1, reg2, reg(ctx));
                break;
            case "~=":
                compute = new Instruction.Compute(Op.NEq, reg1, reg2, reg(ctx));
                break;
            case "==":
                compute = new Instruction.Compute(Op.Equal, reg1, reg2, reg(ctx));
                break;
            default:
                // This should never be reached
                compute = new Instruction.Compute(Op.Gt, reg1, reg2, reg(ctx));
                break;
        }

        addOp(compute);
        setCodeLines(ctx, lines + 1);

        emptyReg(ctx.expr(1));
        emptyReg(ctx.expr(0));
        return DIR;
    }

    @Override
    public String visitParExpr(GuavaParser.ParExprContext ctx) {
        visit(ctx.expr());
        setCodeLines(ctx, getCodeLines(ctx.expr()));
        return DIR;
    }

    @Override
    public String visitArrayExpr(GuavaParser.ArrayExprContext ctx) {
        // TODO: Implement arrays
        return DIR;
    }

    @Override
    public String visitConstExpr(GuavaParser.ConstExprContext ctx) {
        Instruction load = null;
        int lines = 0;

        switch (result.getType(ctx).getKind()) {
            case INT:
                load = new Instruction.LoadConst(ctx.getText(), reg(ctx));
                lines = 1;
                break;
            case BOOL:
                if (ctx.getText().equals("sweet")) {
                    load = new Instruction.LoadConst(TRUE, reg(ctx));
                } else {
                    load = new Instruction.LoadConst(FALSE, reg(ctx));
                }

                lines = 1;
                break;
            case CHAR:
                String ch = ctx.getText().replaceAll("'", "");
                char c = ch.charAt(0);
                int i = (int) c;

                load = new Instruction.LoadConst(String.valueOf(i), reg(ctx));

                lines = 1;
                break;
        }

        if (!isZero(ctx)) {
            addOp(load);
        }

        setCodeLines(ctx, lines);
        return CONST;
    }

    @Override
    public String visitIdExpr(GuavaParser.IdExprContext ctx) {
        Instruction load = null;
        Instruction receive = null;
        int lines = 0;

        if (result.isGlobalVar(ctx.ID())) {
            load = new Instruction.ReadInstr(MemAddr.DirAddr, offset2String(offset(ctx)));
            receive = new Instruction.Receive(reg(ctx));
        } else {
            if (!isNestedVar(ctx.ID())) {
                load = new Instruction.Load(MemAddr.DirAddr, offset2String(offset(ctx.ID())), reg(ctx));
            }
        }

        if (load != null && !isLoadedVariable(ctx.ID())) {
            addOp(load);
            loadVariable(ctx.ID(), reg(ctx));
            lines += 1;
        }

        if (receive != null && !isLoadedVariable(ctx.ID())) {
            addOp(receive);
            loadVariable(ctx.ID(), reg(ctx));
            lines += 1;
        }

        setCodeLines(ctx, lines);
        return DIR;
    }

    /** Assignments in a for loop.*/
    @Override
    public String visitForDecl(GuavaParser.ForDeclContext ctx) {
        int lines = 0;
        if (ctx.expr() != null) {
            visit(ctx.expr());
            lines += getCodeLines(ctx.expr());
        }

        addNestedVar(ctx.ID(), reg(ctx.expr()));
        setCodeLines(ctx, lines);
        return null;
    }

    @Override
    public String visitForExisting(GuavaParser.ForExistingContext ctx) {
        setCodeLines(ctx, 0);
        return null;
    }


    /** Getters and setters. */
    private void addOp(Instruction op) {
        this.operations.add(op.toString());
    }

    private void addOp(Instruction op, int index) {
        this.operations.remove(index);
        this.operations.add(index, op.toString());
    }

    private int reserveOp() {
        this.operations.add("RESERVED");
        return this.operations.size() - 1;
    }

    private void addNestedVar(ParseTree node, String reg) {
        if (!this.nestedVars.containsKey(node.getText())) {
            this.nestedVars.put(node.getText(), reg);
        }
    }

    private void delNestedVar(ParseTree node) {
        if (this.nestedVars.containsKey(node.getText())) {
            this.nestedVars.remove(node.getText());
        }
    }

    private boolean isNestedVar(ParseTree node) {
        return this.nestedVars.containsKey(node.getText());
    }

    private String getNestedVarReg(ParseTree node) {
        return this.nestedVars.get(node.getText());
    }

    private String offset(ParseTree node) {
        return this.result.getOffset(node);
    }

    private String reg(ParseTree node) {
        if (this.registers.get(node) != null) {
            return this.registers.get(node);
        } else {
            this.registers.put(node, emptyRegisters.remove(0));
            return this.registers.get(node);
        }
    }

    private void emptyReg(ParseTree node) {
        if (!nested) {
            this.emptyRegisters.add(0, reg(node));
        }
    }

    private String getReg(ParseTree node) {
        String reg;
        if (isNestedVar(node)) {
            reg = getNestedVarReg(node);
        } else if (isLoadedVariable(node)){
            reg = getLoadedVariable(node);
        } else {
            reg = reg(node);
        }

        return reg;
    }

    private void loadVariable(ParseTree node, String reg) {
        if (!this.loadedVariables.containsKey(node.getText())) {
            this.loadedVariables.put(node.getText(), reg);
            System.out.println("Loaded " + node.getText());
        }
    }

    private boolean isLoadedVariable(ParseTree node) {
        return this.loadedVariables.containsKey(node.getText());
    }

    private String getLoadedVariable(ParseTree node) {
        return this.loadedVariables.get(node.getText());
    }

    private void releaseLoadedVariables() {
        this.loadedVariables = new HashMap<>();
    }

    private String offset2String(String offset) {
        return this.result.getVarMap().get(Integer.parseInt(offset));
    }

    private int getCodeLines(ParseTree node) {
        return this.codeLines.get(node);
    }

    private void setCodeLines(ParseTree node, int i) {
        this.codeLines.put(node, i);
    }

    private void setNext(ParseTree node1, ParserRuleContext node2) {
        this.next.put(node1, node2);
    }

    private ParserRuleContext getNext(ParseTree node) {
        return this.next.get(node);
    }

    private boolean isZero(ParseTree node) {
        return node.getText().equals("0");
    }
}